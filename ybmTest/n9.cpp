//
// Created by 임희진 on 11/4/25.
//
// 문제: 게임 대회에서 승리할 수 있는 경기의 수를 구하는 문제
// - 전략을 아는 사람들이 있음
// - 같은 경기에 참가하는 사람들은 서로 연결됨
// - 전략을 아는 사람과 연결된 사람도 전략을 알게 됨
// - 전략을 모르는 사람들만 참가하는 경기에서만 승리 가능
//
// 해결 방법: Union-Find(Disjoint Set) 자료구조 사용
// - 같은 그룹에 속한 사람들을 하나로 묶음
// - 전략을 아는 그룹과 분리된 그룹만 승리 가능

#include "n9.h"
#include <iostream>
#include <vector>

using namespace std;

// Union-Find 자료구조를 위한 배열
// arr[i] = i의 부모 노드 (루트는 자기 자신을 가리킴)
int arr[200];

/**
 * findboss: Union-Find의 Find 연산 (루트 노드 찾기)
 *
 * @param member 찾고자 하는 멤버의 번호
 * @return 해당 멤버가 속한 그룹의 루트(대표) 노드
 *
 * 경로 압축(Path Compression) 최적화 적용:
 * - 재귀적으로 루트를 찾으면서, 중간 경로의 모든 노드를 루트에 직접 연결
 * - 시간복잡도: O(α(n)) - 거의 상수 시간
 *
 * 예시:
 * 4 → 3 → 2 → 1 → 0 (루트)
 * findboss(4) 호출 후:
 * 4 → 0, 3 → 0, 2 → 0, 1 → 0 (모두 루트에 직접 연결)
 */
int findboss(int member) {
    // 기저 조건: 자기 자신이 루트인 경우
    if (arr[member] == member) return member;

    // 재귀적으로 루트를 찾음
    int ret = findboss(arr[member]);

    // 경로 압축: 현재 노드를 루트에 직접 연결
    // 다음에 같은 노드를 찾을 때 O(1)로 찾을 수 있음
    arr[member] = ret;

    return ret;
}

/**
 * setunion: Union-Find의 Union 연산 (두 그룹 합치기)
 *
 * @param a 첫 번째 멤버
 * @param b 두 번째 멤버
 *
 * 두 멤버가 속한 그룹을 하나로 합침
 * - a의 루트를 찾고, b의 루트를 찾음
 * - b의 루트를 a의 루트 아래에 연결
 *
 * 예시:
 * 그룹1: 0 ← 1 ← 2
 * 그룹2: 3 ← 4
 * setunion(2, 4) 호출 시:
 * 0 ← 3 (그룹2의 루트 3이 그룹1의 루트 0 아래로 연결됨)
 *   ↑   ↑
 *   1   4
 *   ↑
 *   2
 */
void setunion(int a, int b) {
    // 각각의 루트(보스) 찾기
    int bossA = findboss(a);
    int bossB = findboss(b);

    // 이미 같은 그룹에 속해있으면 아무것도 하지 않음
    if (bossA == bossB) return;

    // B의 루트를 A의 루트 아래에 연결
    // 이제 B 그룹의 모든 멤버는 A 그룹에 속하게 됨
    arr[bossB] = bossA;
}

/**
 * solution: 승리할 수 있는 경기의 수를 계산
 *
 * @param N 전체 참가자 수 (0 ~ N-1번까지의 사람)
 * @param info 전략 정보
 *             info[0][0] = 전략을 아는 사람의 수
 *             info[1] = 전략을 아는 사람들의 번호 배열
 * @param game 경기 정보
 *             game[i] = i번째 경기에 참가하는 사람들의 번호 배열
 * @return 승리할 수 있는 경기의 수
 *
 * 알고리즘 흐름:
 * 1. Union-Find 초기화
 * 2. 전략을 아는 사람들을 하나의 그룹으로 묶음
 * 3. 같은 경기에 참가하는 사람들을 그룹으로 묶음
 * 4. 각 경기마다 전략을 아는 그룹이 포함되어 있는지 확인
 * 5. 전략을 아는 그룹이 없는 경기만 승리 가능
 */
int solution(int N, vector<vector<int> > info, vector<vector<int> > game)
{
    int result = 0;  // 승리 가능한 경기 수

    // ========== 1단계: Union-Find 초기화 ==========
    // 처음에는 모든 사람이 독립적인 그룹
    // arr[i] = i로 설정 (자기 자신이 루트)
    for (int i = 0; i < N; i++) {
        arr[i] = i;
    }

    // ========== 2단계: 전략을 아는 사람들을 하나의 그룹으로 합치기 ==========
    // 전략을 아는 사람들끼리는 정보를 공유하므로 하나의 그룹으로 묶음
    int knowCount = info[0][0];  // 전략을 아는 사람의 수

    if (knowCount > 0) {
        // 첫 번째 사람을 기준으로 나머지 사람들을 합침
        int firstKnow = info[1][0];
        for (int i = 1; i < knowCount; i++) {
            setunion(firstKnow, info[1][i]);
        }
        // 결과: 전략을 아는 사람들은 모두 같은 루트를 가짐
    }

    // ========== 3단계: 같은 경기에 참가하는 사람들을 그룹화 ==========
    // 같은 경기에 참가하면 서로 연결됨 (정보 공유 가능)
    // 만약 그 중 한 명이라도 전략을 알면, 그룹 전체가 전략을 알게 됨
    for (int i = 0; i < game.size(); i++) {
        if (game[i].size() > 1) {
            // 경기의 첫 번째 사람을 기준으로 나머지 사람들을 합침
            for (int j = 1; j < game[i].size(); j++) {
                setunion(game[i][0], game[i][j]);
            }
        }
    }
    // 예시:
    // game = {{1, 2}, {3}, {3, 4}}
    // - 1과 2가 같은 그룹
    // - 3과 4가 같은 그룹

    // ========== 4단계: 전략을 아는 그룹의 대표(루트) 찾기 ==========
    int knowBoss = -1;  // 전략을 아는 그룹의 루트 번호
    if (knowCount > 0) {
        knowBoss = findboss(info[1][0]);
    }
    // 이제 어떤 사람이 전략을 아는지 확인하려면
    // findboss(그 사람) == knowBoss인지 비교하면 됨

    // ========== 5단계: 각 경기마다 승리 가능한지 확인 ==========
    for (int i = 0; i < game.size(); i++) {
        bool canWin = true;  // 이 경기에서 승리 가능한가?

        // 경기 참가자 중 한 명이라도 전략을 아는 그룹에 속하면 패배
        for (int j = 0; j < game[i].size(); j++) {
            int participant = game[i][j];

            // 이 참가자가 전략을 아는 그룹에 속해있는지 확인
            if (knowBoss != -1 && findboss(participant) == knowBoss) {
                canWin = false;  // 전략을 아는 그룹이므로 패배
                break;
            }
        }

        // 전략을 아는 사람이 없으면 승리
        if (canWin) {
            result++;
        }
    }

    return result;
}

/**
 * main: 테스트케이스를 실행하는 메인 함수
 */
int main()
{
    // ========== 테스트케이스 1 ==========
    // N = 5: 참가자는 0, 1, 2, 3, 4번
    int N = 5;

    // info = {{1}, {4}}
    // - 전략을 아는 사람: 1명 (4번)
    vector<vector<int>> info = {{1}, {4}};

    // game = {{1, 2}, {3}, {3, 4}}
    // - 경기 1: 1번과 2번이 참가 → 1, 2 그룹화
    // - 경기 2: 3번만 참가
    // - 경기 3: 3번과 4번이 참가 → 3, 4 그룹화 (4는 전략을 아는 사람)
    vector<vector<int>> game = {{1, 2}, {3}, {3, 4}};

    // 그룹 상황:
    // - 그룹 A: {1, 2} (전략 모름)
    // - 그룹 B: {3, 4} (4가 전략을 알므로 그룹 전체가 전략을 앎)
    // - 독립: {0} (전략 모름)
    //
    // 경기별 승리 가능 여부:
    // - 경기 1 {1, 2}: 전략 모름 → 승리 가능 ✅
    // - 경기 2 {3}: 3은 4와 그룹 → 전략을 앎 → 승리 불가 ❌
    // - 경기 3 {3, 4}: 4가 전략을 앎 → 승리 불가 ❌
    //
    // 예상 결과: 1
    int ret = solution(N, info, game);
    cout << "solution 함수의 반환 값은 " << ret << " 입니다." << endl;

    // ========== 테스트케이스 2 ==========
    // N = 7: 참가자는 0, 1, 2, 3, 4, 5, 6번
    int N2 = 7;

    // info = {{3}, {1, 2, 3}}
    // - 전략을 아는 사람: 3명 (1, 2, 3번)
    vector<vector<int>> info2 = {{3}, {1, 2, 3}};

    // game = {{1}, {2}, {3}, {4}, {5}, {6}, {4, 5}, {3, 6}}
    // - 경기 1: {1} → 전략을 앎
    // - 경기 2: {2} → 전략을 앎
    // - 경기 3: {3} → 전략을 앎
    // - 경기 4: {4} → 전략 모름
    // - 경기 5: {5} → 전략 모름
    // - 경기 6: {6} → 전략 모름
    // - 경기 7: {4, 5} → 4, 5 그룹화, 전략 모름
    // - 경기 8: {3, 6} → 3, 6 그룹화, 3이 전략을 아므로 6도 전략을 알게 됨
    vector<vector<int>> game2 = {{1}, {2}, {3}, {4}, {5}, {6}, {4, 5}, {3, 6}};

    // 그룹 상황:
    // - 그룹 A: {1, 2, 3, 6} (전략을 앎)
    // - 그룹 B: {4, 5} (전략 모름)
    // - 독립: {0} (전략 모름)
    //
    // 경기별 승리 가능 여부:
    // - 경기 1 {1}: 전략을 앎 → 승리 불가 ❌
    // - 경기 2 {2}: 전략을 앎 → 승리 불가 ❌
    // - 경기 3 {3}: 전략을 앎 → 승리 불가 ❌
    // - 경기 4 {4}: 전략 모름 → 승리 가능 ✅
    // - 경기 5 {5}: 전략 모름 → 승리 가능 ✅
    // - 경기 6 {6}: 3과 그룹화되어 전략을 앎 (경기 8 이후) → 승리 불가 ❌
    // - 경기 7 {4, 5}: 전략 모름 → 승리 가능 ✅
    // - 경기 8 {3, 6}: 전략을 앎 → 승리 불가 ❌
    //
    // 예상 결과: 3 (경기 4, 5, 7)
    int ret2 = solution(N2, info2, game2);
    cout << "solution 함수의 반환 값은 " << ret2 << " 입니다." << endl;

    return 0;
}